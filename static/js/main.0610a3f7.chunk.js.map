{"version":3,"sources":["util/set.ts","function_dependency.ts","util/matrix.ts","relation.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["clone","a","Set","union","b","intersect","filter","x","has","difference","isSubSet","maybeSubSet","superSet","element","FunctionDependency","from","to","Array","this","join","s","split","trim","result","row","push","Relation","fds","properties","fd","add","fdStrs","it","includes","map","parse","rests","rest","addProperty","property","last_size","all_in","size","lhs","rhs","propertyClosure","existInRight","existInLeft","mustHave","mustNotHave","possibleToHave","possibleToHaveElement","mayBeCandidateKey","candidateKeys","reduce","keyCodes","attribute","candidateKey","toRemove","partialCandidateKey","delete","canDecide","secondNF","keyAttributes","leftIsSuperkey","relation","eliminatePropertyResult","eliminatePropertyProcess","eliminateFDResult","eliminateFDProcess","eliminateProperty","process","eliminateFD","oldFDs","newFDs","newFrom","closureAfterEliminate","canEliminate","oldFD","propertyEliminated","columns","sort","rows","matrix","i","length","matrixRow","col","initialMatrix","matrixClone","canExit","fdTo","selectedColumns","indexOf","sameRows","j","allColumnsSame","column","minValue","Infinity","oldValue","Math","min","useFD","resultMatrix","allA","changed","toRelation","newResult","failOnFd","App","useState","setRelation","input","setInput","findClosure","setFindClosure","decomposeIntoStr","setDecomposeIntoStr","decomposeInto","setDecomposeInto","className","value","onChange","event","target","onClick","minify","toString","type","name","checked","disabled","thirdNF","BCNF","isLosslessDecompose","preserveFDDecompose","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.0610a3f7.chunk.js","sourcesContent":["export function clone<T>(a: Set<T>): Set<T> {\n    return new Set([...a]);\n}\n\nexport function union<T>(a: Set<T>, b: Set<T>): Set<T> {\n    return new Set([...a, ...b])\n}\n\nexport function intersect<T>(a: Set<T>, b: Set<T>): Set<T> {\n    return new Set([...a].filter(x => b.has(x)))\n}\n\nexport function difference<T>(a: Set<T>, b: Set<T>): Set<T> {\n    return new Set([...a].filter(x => !b.has(x)))\n}\n\nexport function isSubSet<T>(maybeSubSet: Set<T>, superSet: Set<T>) {\n    for (const element of maybeSubSet) {\n        if (!superSet.has(element)) {\n            return false;\n        }\n    }\n    return true;\n}\n","import {isSubSet} from \"./util/set\";\n\nexport class FunctionDependency {\n    public constructor(public readonly from: Set<string>,\n                       public readonly to: Set<string>) {\n    }\n\n    get isTrivial(): boolean {\n        return isSubSet(this.to, this.from)\n    }\n\n    static parse(s: string): FunctionDependency {\n        let [from, to] = s.split(\"->\", 2);\n        return new FunctionDependency(\n            new Set(from.trim()),\n            new Set(to.trim())\n        )\n    }\n\n    public toString() {\n        return Array.from(this.from).join('') + \"->\" + Array.from(this.to).join('');\n    }\n}\n","export function clone<T>(a: Array<Array<T>>): Array<Array<T>> {\n    let result = [];\n    for (const row of a) {\n        result.push([...row]);\n    }\n    return result;\n}\n","import {FunctionDependency} from \"./function_dependency\";\nimport {clone, difference, intersect, isSubSet, union} from \"./util/set\";\nimport {clone as matrixClone} from \"./util/matrix\";\n\nexport interface EliminatePropertyProcess {\n    oldFD: FunctionDependency,\n    propertyEliminated: string,\n    closureAfterEliminate: Set<string>,\n    canEliminate: boolean\n}\n\nexport interface EliminateFDProcess {\n    fd: FunctionDependency,\n    closureAfterEliminate: Set<string>,\n    canEliminate: boolean\n}\n\nexport interface MinifyProcess {\n    eliminateProperty: Array<EliminatePropertyProcess>\n    eliminateFD: Array<EliminateFDProcess>,\n    result: Relation\n}\n\nexport interface CheckLosslessDecomposeProcess {\n    process: Array<{\n        useFD: FunctionDependency,\n        resultMatrix: Array<Array<'A' | number>>\n    }>\n}\n\nexport class Relation {\n    readonly properties: Set<string>;\n    readonly fds: Set<FunctionDependency>;\n\n    public static parse(s: string): Relation {\n        let fdStrs = s.split(',');\n        let fds = new Set(fdStrs\n            .filter((it) => it.includes('->'))\n            .map(FunctionDependency.parse));\n        let result = new Relation(fds);\n        let rests = fdStrs.filter((it) => !it.includes('->'));\n        for (const rest of rests) {\n            for (const element of rest) {\n                result.addProperty(element);\n            }\n        }\n        return result;\n    }\n\n    public constructor(\n        fds: Set<FunctionDependency>\n    ) {\n        this.fds = new Set<FunctionDependency>();\n        for (const fd of fds) {\n            for (const to of fd.to) {\n                this.fds.add(new FunctionDependency(fd.from, new Set([to])));\n            }\n        }\n        this.properties = new Set<string>();\n        for (const fd of fds) {\n            this.properties = union(this.properties, fd.from);\n            this.properties = union(this.properties, fd.to);\n        }\n    }\n\n    public addProperty(property: string) {\n        this.properties.add(property)\n    }\n\n    public addFD(fd: FunctionDependency) {\n        for (let to of fd.to) {\n            this.fds.add(new FunctionDependency(fd.from, new Set<string>(to)));\n        }\n    }\n\n    public propertyClosure(properties: Set<string>): Set<string> {\n        let result = new Set([...properties]);\n        let last_size = 1;\n        while (true) {\n            for (const fd of this.fds) {\n                let all_in = true;\n                for (const from of fd.from) {\n                    if (!result.has(from)) {\n                        all_in = false;\n                        break;\n                    }\n                }\n                if (all_in) {\n                    for (const to of fd.to) {\n                        result.add(to)\n                    }\n                }\n            }\n            if (result.size === last_size) {\n                break;\n            } else {\n                last_size = result.size;\n            }\n        }\n        return result;\n    }\n\n    public canDecide(lhs: Set<string>, rhs: Set<string>): boolean {\n        return isSubSet(rhs, this.propertyClosure(lhs));\n    }\n\n    get candidateKeys(): Set<Set<string>> {\n        let existInRight = new Set<string>();\n        let existInLeft = new Set<string>();\n        for (const fd of this.fds) {\n            existInRight = union(existInRight, fd.to);\n            existInLeft = union(existInLeft, fd.from);\n        }\n        let mustHave = difference(this.properties, existInRight);\n        let mustNotHave = difference(existInRight, existInLeft);\n        let possibleToHave = difference(difference(this.properties, mustHave), mustNotHave);\n        let result = new Set<Set<string>>();\n        if (this.propertyClosure(mustHave).size === this.properties.size) {\n            result.add(mustHave);\n        } else {\n            for (const possibleToHaveElement of possibleToHave) {\n                let mayBeCandidateKey = union(mustHave, new Set([possibleToHaveElement]));\n                if (this.propertyClosure(mayBeCandidateKey).size === this.properties.size) {\n                    result.add(mayBeCandidateKey);\n                }\n            }\n        }\n        return result;\n    }\n\n    get keyAttributes(): Set<string> {\n        return new Set(Array.from(this.candidateKeys)\n            .reduce((a, b) => union(a, b)));\n    }\n\n    static minify(relation: Relation): MinifyProcess {\n        let eliminatePropertyResult = this.eliminatePropertyProcess(relation);\n        let eliminateFDResult = this.eliminateFDProcess(eliminatePropertyResult.result);\n        return {\n            eliminateProperty: eliminatePropertyResult.process,\n            eliminateFD: eliminateFDResult.process,\n            result: eliminateFDResult.result\n        }\n    }\n\n    public static eliminatePropertyProcess(relation: Relation): { process: Array<EliminatePropertyProcess>, result: Relation } {\n        let eliminatePropertyProcess = [];\n        let oldFDs = relation.fds;\n        let newFDs = clone(oldFDs);\n        for (const fd of oldFDs) {\n            if (fd.from.size > 1) {\n                newFDs.delete(fd);\n                let newFrom = clone(fd.from);\n                for (const toRemove of fd.from) {\n                    newFrom.delete(toRemove);\n                    let closureAfterEliminate = relation.propertyClosure(newFrom)\n                    let canEliminate = isSubSet(fd.to, closureAfterEliminate);\n                    eliminatePropertyProcess.push({\n                        oldFD: fd,\n                        propertyEliminated: toRemove,\n                        closureAfterEliminate,\n                        canEliminate\n                    });\n                    if (!canEliminate) {\n                        newFrom.add(toRemove);\n                    }\n                }\n                newFDs.add(new FunctionDependency(newFrom, fd.to));\n            }\n        }\n        return {\n            process: eliminatePropertyProcess,\n            result: new Relation(newFDs)\n        }\n    }\n\n    public static eliminateFDProcess(relation: Relation): { process: Array<EliminateFDProcess>, result: Relation } {\n        let eliminateFDProcess = [];\n        let oldFDs = relation.fds;\n        let newFDs = clone(oldFDs);\n        for (const fd of oldFDs) {\n            newFDs.delete(fd);\n            let eliminated = new Relation(newFDs);\n            let closureAfterEliminate = eliminated.propertyClosure(fd.from);\n            let canEliminate = isSubSet(fd.to, closureAfterEliminate);\n            eliminateFDProcess.push({\n                fd,\n                closureAfterEliminate,\n                canEliminate\n            });\n            if (!canEliminate) {\n                newFDs.add(fd);\n            }\n        }\n        return {\n            process: eliminateFDProcess,\n            result: new Relation(newFDs)\n        }\n    }\n\n    public static isLosslessDecompose(to: Set<Relation>, from: Relation): {\n        initialMatrix: Array<Array<'A' | number>>,\n        process: CheckLosslessDecomposeProcess,\n        result: boolean\n    } {\n        let result = false;\n        let process: CheckLosslessDecomposeProcess = {process: []};\n        let columns = Array.from(from.properties).sort();\n        let rows = Array.from(to);\n        let matrix: Array<Array<'A' | number>> = [];\n        for (let i = 0; i < rows.length; ++i) {\n            let row = rows[i];\n            let matrixRow: Array<'A' | number> = [];\n            for (const col of columns) {\n                if (row.properties.has(col)) {\n                    matrixRow.push('A')\n                } else {\n                    matrixRow.push(i + 1);\n                }\n            }\n            matrix.push(matrixRow);\n        }\n        let initialMatrix = matrixClone(matrix);\n        let canExit = false;\n        while (!canExit) {\n            canExit = true;\n            for (const fd of from.fds) {\n                let fdTo = Array.from(fd.to)[0];\n                let selectedColumns = Array.from(fd.from)\n                    .map((it) => columns.indexOf(it));\n                // finding out which rows are all same with matrix[i][selectedColumns]\n                let sameRows = [0];\n                for (let i = 0; i < rows.length - 1; ++i) {\n                    sameRows = [i];\n                    for (let j = i + 1; j < rows.length; ++j) {\n                        let allColumnsSame = true;\n                        for (const column of selectedColumns) {\n                            if (matrix[i][column] !== matrix[j][column]) {\n                                allColumnsSame = false;\n                                break;\n                            }\n                        }\n                        if (allColumnsSame) {\n                            sameRows.push(j);\n                        }\n                    }\n                    if (sameRows.length >= 2) {\n                        break;\n                    }\n                }\n                if (sameRows.length !== 1) {\n                    // change matrix[sameRows][fd.to] into min(matrix[sameRows][fd.to])\n                    let minValue: 'A' | number = Infinity;\n                    for (const row of sameRows) {\n                        let oldValue = matrix[row][columns.indexOf(fdTo)];\n                        if (oldValue === 'A') {\n                            minValue = 'A';\n                            break;\n                        } else {\n                            minValue = Math.min(minValue, oldValue);\n                        }\n                    }\n                    for (const row of sameRows) {\n                        if (matrix[row][columns.indexOf(fdTo)] !== minValue) {\n                            canExit = false;\n                            matrix[row][columns.indexOf(fdTo)] = minValue;\n                        }\n                    }\n                }\n                process.process.push({\n                    useFD: fd,\n                    resultMatrix: matrixClone(matrix)\n                });\n                for (const row of matrix) {\n                    let allA = true;\n                    for (const col of row) {\n                        if (col !== 'A') {\n                            allA = false;\n                            break;\n                        }\n                    }\n                    if (allA) {\n                        canExit = true;\n                        result = true;\n                        break;\n                    }\n                }\n            }\n        }\n        return {\n            process,\n            result,\n            initialMatrix\n        }\n    }\n\n    public static preserveFDDecompose(to: Set<Relation>, from: Relation): { result: boolean, failOnFd?: FunctionDependency } {\n        for (const fd of from.fds) {\n            let result = clone(fd.from);\n            let changed: boolean;\n            do {\n                changed = false;\n                for (const toRelation of to) {\n                    let t = intersect(from.propertyClosure(intersect(result, toRelation.properties)), toRelation.properties)\n                    let newResult = union(result, t);\n                    if (newResult.size !== result.size) {\n                        result = newResult;\n                        changed = true;\n                    }\n                }\n            } while (changed);\n            if (!isSubSet(fd.to, result)) {\n                return {result: false, failOnFd: fd};\n            }\n        }\n        return {result: true}\n    }\n\n    get secondNF(): boolean {\n        let keyCodes = this.keyCodes;\n        let candidateKeys = this.candidateKeys;\n        for (const attribute of this.properties) {\n            let isKeyCode = keyCodes.has(attribute);\n            if (isKeyCode) continue;\n            for (const candidateKey of candidateKeys) {\n                for (const toRemove of candidateKey) {\n                    let partialCandidateKey = clone(candidateKey);\n                    partialCandidateKey.delete(toRemove);\n                    if (this.canDecide(partialCandidateKey, new Set(attribute))) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    get keyCodes(): Set<string> {\n        let keyCodes = new Set<string>();\n        for (const candidateKey of this.candidateKeys) {\n            keyCodes = union(keyCodes, candidateKey);\n        }\n        return keyCodes;\n    }\n\n    get thirdNF(): boolean {\n        if (!this.secondNF) {\n            return false;\n        }\n        let candidateKeys = this.candidateKeys;\n        let keyAttributes = this.keyAttributes;\n        for (const fd of this.fds) {\n            let leftIsSuperkey = false;\n            for (const candidateKey of candidateKeys) {\n                if (isSubSet(candidateKey, fd.from)) {\n                    leftIsSuperkey = true;\n                    break;\n                }\n            }\n            if (!leftIsSuperkey) {\n                for (const attribute of fd.to) {\n                    if (!keyAttributes.has(attribute)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    get BCNF(): boolean {\n        if (!this.secondNF) {\n            return false;\n        }\n        let candidateKeys = this.candidateKeys;\n        for (const fd of this.fds) {\n            let leftIsSuperkey = false;\n            for (const candidateKey of candidateKeys) {\n                if (isSubSet(candidateKey, fd.from)) {\n                    leftIsSuperkey = true;\n                    break;\n                }\n            }\n            if (!leftIsSuperkey) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public toString() {\n        return Array.from(this.fds).join(',');\n    }\n}\n","import React, {useState} from 'react';\nimport './App.css';\nimport {Relation} from \"./relation\";\n\nfunction App() {\n    let [relation, setRelation] = useState(new Relation(new Set()));\n    let [input, setInput] = useState(\"\");\n    let [findClosure, setFindClosure] = useState(\"\");\n    let [decomposeIntoStr, setDecomposeIntoStr] = useState(\"\");\n    let [decomposeInto, setDecomposeInto] = useState(new Set<Relation>());\n    return (\n        <div className=\"App\">\n            <header className=\"App-header\">\n                <input value={input} onChange={event => setInput((event.target as any).value)}/>\n                <button onClick={() => {\n                    setRelation(Relation.parse(input.split('-').join('->')))\n                }}>确定\n                </button>\n                <div>候选键：{\n                    Array.from(relation.candidateKeys)\n                        .map(it => Array.from(it).join(''))\n                        .join(',')\n                }</div>\n                <div>主属性：{\n                    Array.from(relation.keyAttributes)\n                        .join(',')\n                }</div>\n                <div><input value={findClosure} onChange={event => setFindClosure((event.target as any).value)}/>{\n                    '+ = {' + Array.from(relation.propertyClosure(new Set(findClosure.split('')))).join('') + '}'\n                }</div>\n                <div>F+={Relation.minify(relation).result.toString()}</div>\n                2NF:<input type=\"checkbox\" name=\"2nf\" checked={relation.secondNF} disabled={true}/>\n                3NF:<input type=\"checkbox\" name=\"3nf\" checked={relation.thirdNF} disabled={true}/>\n                BCNF:<input type=\"checkbox\" name=\"bcnf\" checked={relation.BCNF} disabled={true}/>\n                <div>\n                    <input value={decomposeIntoStr}\n                           onChange={event => setDecomposeIntoStr((event.target as any).value)}/>\n                    <button onClick={() => {\n                        setDecomposeInto(new Set(decomposeIntoStr.split(',').map(Relation.parse)))\n                    }}>确定\n                    </button>\n                    <div>无损:<input type=\"checkbox\" name=\"lossless\"\n                                   checked={Relation.isLosslessDecompose(decomposeInto, relation).result}\n                                   disabled={true}/>\n                    </div>\n                    <div>保持函数依赖:<input type=\"checkbox\" name=\"keepfd\"\n                                       checked={Relation.preserveFDDecompose(decomposeInto, relation).result}\n                                       disabled={true}/>\n                    </div>\n                </div>\n            </header>\n        </div>\n    );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}